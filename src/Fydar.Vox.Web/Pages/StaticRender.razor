@using Fydar.Vox.Meshing;
@using System;
@using System.Numerics;
@using Fydar.Vox.VoxFiles;

@page "/staticrender"
@inject HttpClient Http

<h1>Static Render</h1>

<style>
	.scene {
		display: inline-block;
		padding: 50px;
		perspective: 2048px;
		border: 1px solid #eee;
		overflow: hidden;
	}

	.mesh {
		position: relative;
		width: 250px;
		height: 500px;
		transform-style: preserve-3d;
		transition: transform 0.6s;
	}

	.surface {
		transform-origin: 0% 0%;
	}

	.face {
		position: absolute;
		width: @(faceSize)px;
		height: @(faceSize)px;
		border: 1px solid #0006;
	}
</style>

<div class="scene">

	@{
		GroupedMesh? mesh = null;
		if (DemoModels.Models != null)
		{
			if (DemoModels.Models[Model].Grouped.Surfaces != null)
			{
				mesh = DemoModels.Models[Model].Grouped;
			}
		}
	}


	@if (mesh != null)
	{
	<div class="mesh" style="width: @(faceSize * Width)px; height: @(faceSize * Height)px; transform: scale(@scale) scaleY(-1) rotateX(@(Pitch)deg) rotateY(@(Direction)deg) translate3d(0, 0, @(faceSize * (Depth - 1) * -0.5f)px) ">

		@foreach (var surfaces in mesh.Value.Surfaces)
		{
			<div class="surface" style="transform: @ToTransform(surfaces.Description)">
				@foreach (var face in surfaces.Faces)
				{
					<div class="face" style="
									transform: translate(@(face.Position.x * faceSize)px, @(face.Position.y * faceSize)px);
									background-color: @surfaces.Description.Colour.ToHexString();">

					</div>
				}
			</div>
		}
	</div>
	}
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Model</div>
	<div style="width: 64px;">@Model</div>
	<input type="range" style="flex-grow: 1" min="0" max="@(DemoModels.Models?.Count - 1 ?? 0)" @bind="@Model" @bind:event="oninput" />
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Width</div>
	<div style="width: 64px;">@Width</div>
	<input type="range" style="flex-grow: 1" min="0" max="25" @bind="@Width" @bind:event="oninput" />
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Height</div>
	<div style="width: 64px;">@Height</div>
	<input type="range" style="flex-grow: 1" min="0" max="25" @bind="@Height" @bind:event="oninput" />
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Depth</div>
	<div style="width: 64px;">@Depth</div>
	<input type="range" style="flex-grow: 1" min="0" max="25" @bind="@Depth" @bind:event="oninput" />
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Direction</div>
	<div style="width: 64px;">@Direction</div>
	<input type="range" style="flex-grow: 1" min="0" max="360" @bind="@Direction" @bind:event="oninput" />
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Pitch</div>
	<div style="width: 64px;">@Pitch</div>
	<input type="range" style="flex-grow: 1" min="-90" max="90" @bind="@Pitch" @bind:event="oninput" />
</div>

@code {
		static int faceSize = 50;
		static float scale = 0.5f;

		private int Model = 0;

		private int Width = 6;
		private int Height = 10;
		private int Depth = 6;

		private float Pitch = 45.0f;
		private float Direction = 30.0f;

		protected override async Task OnInitializedAsync()
		{
			await DemoModels.Init(Http);
		}
}

@functions {
	public static string ToTransform(SurfaceDescription surface)
	{
		var normal = surface.Normal;
		int depth = surface.Depth;

		if (normal == VoxelNormal.Up)
		{
			return $"rotateX(90deg) translate3d(0, 0, {depth * -faceSize}px)";
		}
		else if (normal == VoxelNormal.Down)
		{
			return $"rotateX(90deg) translate3d(0, 0, {depth * faceSize}px)";
		}
		else if (normal == VoxelNormal.Left)
		{
			return $"rotateY(-90deg) translate3d(0px, 0, {depth * faceSize}px)";
		}
		else if (normal == VoxelNormal.Right)
		{
			return $"rotateY(-90deg) translate3d(0px, 0, {depth * -faceSize}px)";
		}
		else if (normal == VoxelNormal.Back)
		{
			return $"translate3d(0, 0, {depth * -faceSize}px)";
		}
		else if (normal == VoxelNormal.Forward)
		{
			return $"translate3d(0, 0, {depth * faceSize}px)";
		}
		return "";
	}
}
