@using Fydar.Vox.Voxelizer;
@using System;
@using System.Numerics;

@page "/greedymesh"
@inject HttpClient Http

<h1>Mesh</h1>

@functions {
	struct TransformedFace
	{
		public Vector3 V1;
		public Vector3 V2;
		public Vector3 V3;
		public Vector3 V4;
		public Colour24 Color;

		public Vector3 Average
		{
			get
			{
				return (V1 + V2 + V3 + V4) / 4;
			}
		}
	}

	public static float ConvertDegreesToRadians(float degrees)
	{
		float radians = ((float)Math.PI / 180.0f) * degrees;
		return radians;
	}

	public static Vector3 ClipToScreenSpace(Vector3 clipSpace)
	{
		return (clipSpace + new Vector3(1.0f, 1.0f, 0)) * new Vector3(0.5f, 0.5f, 1.0f);
	}
}

@{
	var objectPosition = Vector3SByte.Zero;
}

@if (mesh.Surfaces != null)
{
	<svg width="620" height="420" style="border: 1px solid #eee">
		@{
			var faces = new List<TransformedFace>();
			var fovRadians = ConvertDegreesToRadians(FoV);
			var rotationXRadians = ConvertDegreesToRadians(RotationX);
			var rotationYRadians = ConvertDegreesToRadians(RotationY);
			if (LockXYRotation)
			{
				RotationX = RotationY;
			}
		}
		@foreach (var group in mesh.Surfaces)
		{
			@foreach (var face in group.TransformedFaces)
			{
				var localToWorldSpaceMatrix =
					Matrix4x4.CreateScale(0.2f)
					* Matrix4x4.CreateRotationX(rotationXRadians)
					* Matrix4x4.CreateRotationY(rotationYRadians)
					* Matrix4x4.CreateTranslation(PositionX, PositionY, PositionZ);

				var worldToViewSpace = Matrix4x4.CreateTranslation(0.0f, 0.0f, 10.0f);

				var viewToClipSpaceMatrix = Matrix4x4.CreatePerspectiveFieldOfView(fovRadians, 1.0f, 1.0f, 500.0f);


				var matrix = localToWorldSpaceMatrix * worldToViewSpace * viewToClipSpaceMatrix;

				var v1 = new Vector3(face.TopLeft.x, face.TopLeft.y, face.TopLeft.z);
				var v2 = new Vector3(face.TopRight.x, face.TopRight.y, face.TopRight.z);
				var v3 = new Vector3(face.BottomRight.x, face.BottomRight.y, face.BottomRight.z);
				var v4 = new Vector3(face.BottomLeft.x, face.BottomLeft.y, face.BottomLeft.z);

				var v1s = ClipToScreenSpace(Vector3.Transform(v1, matrix));
				var v2s = ClipToScreenSpace(Vector3.Transform(v2, matrix));
				var v3s = ClipToScreenSpace(Vector3.Transform(v3, matrix));
				var v4s = ClipToScreenSpace(Vector3.Transform(v4, matrix));

				if (v1s.X < 0 || v1s.X > 1.0f
					|| v2s.X < 0 || v2s.X > 1.0f
					|| v3s.X < 0 || v3s.X > 1.0f
					|| v4s.X < 0 || v4s.X > 1.0f)
				{
					continue;
				}

				v1s *= new Vector3(620.0f, 620.0f, 1.0f);
				v2s *= new Vector3(620.0f, 620.0f, 1.0f);
				v3s *= new Vector3(620.0f, 620.0f, 1.0f);
				v4s *= new Vector3(620.0f, 620.0f, 1.0f);

				var trans = new TransformedFace()
				{
					V1 = v1s,
					V2 = v2s,
					V3 = v3s,
					V4 = v4s,
					Color = group.Description.Colour
				};

				// Draw a grayscale colour based on vertex distance.
				// trans.Color = Colour24.Lerp(Colour24.White, Colour24.Black,
				// 	Math.Clamp((float)trans.Average.Z / 2.0f, 0.0f, 1.0f));

				faces.Add(trans);
			}
		}
		@{
			var sortedFaces = faces.OrderBy(face => face.Average.Z).ToList();

			@foreach (var face in sortedFaces)
			{
				if (face.Average.Z < 0)
				{
					continue;
				}

				<polygon points="@face.V1.X,@face.V1.Y @face.V2.X,@face.V2.Y @face.V3.X,@face.V3.Y @face.V4.X,@face.V4.Y"
						 style="fill: @face.Color.ToHexString(); stroke: #333; stroke-width: 1; fill-rule: evenodd;" />
			}
		}

	</svg>
}

<div class="input-group">
	<input type="text" @bind="@PositionX" />
	<input type="text" @bind="@PositionY" />
	<input type="text" @bind="@PositionZ" />
</div>
<p>@PositionX, @PositionY, @PositionZ</p>

<div class="input-group">
	<input type="range" min="1" max="179" @bind="@FoV" @bind:event="oninput" />
	<p>@FoV</p>
</div>

<div class="input-group">
	<input type="range" min="-179" max="179" @bind="@RotationX" @bind:event="oninput" />
	<p>@RotationX</p>
</div>

<div class="input-group">
	<input type="range" min="-179" max="179" @bind="@RotationY" @bind:event="oninput" />
	<p>@RotationY</p>
</div>

<div class="input-group">
	LockXYRotation: <input type="checkbox" @bind="@LockXYRotation" />
</div>

@code {
	private GreedyMesh mesh = DemoModels.GreedyShapeA;

	private float PositionX = -0.1f;
	private float PositionY = -0.5f;
	private float PositionZ = -12.5f;

	private float RotationX = 0.0f;
	private float RotationY = 0.0f;
	private bool LockXYRotation = false;

	private float FoV = 90.0f;


	protected override async Task OnInitializedAsync()
	{
		await DemoModels.Init(Http);

		mesh = DemoModels.GreedyShapeA;
	}
}
