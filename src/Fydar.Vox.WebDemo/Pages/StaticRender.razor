@using Fydar.Vox.Meshing;
@using System;
@using System.Text;
@using System.Numerics;
@using Fydar.Vox.VoxFiles;
@using System.Text.Encodings.Web;

@page "/staticrender"
@inject HttpClient Http

<h1>Static Render</h1>

<div style="min-height: 720px; width: 100%; overflow: hidden;">

	<style>
		.scene {
			display: inline-block;
			perspective: 2048px;
			overflow: hidden;
			box-sizing: border-box;
		}

			.scene .mesh {
				position: relative;
				margin: auto;
				transform-style: preserve-3d;
				transition: transform 0.6s;
			}

				.scene .mesh .element {
					transform-style: preserve-3d;
				}

				.scene .mesh .surface {
					transform-origin: 0% 0%;
					position: absolute;
				}

					.scene .mesh .surface div {
						position: absolute;
						-webkit-backface-visibility: hidden;
						backface-visibility: hidden;
						-webkit-background-clip: content-box;
						background-clip: content-box;
						outline: 1px solid transparent;
					}
	</style>

	<div class="scene" style="padding: 50px 30px 50px 30px;">
		@{
			string name = "no mesh";
			GreedyMesh? mesh = null;
			int width = 1;
			int height = 1;
			int depth = 1;

			if (DemoModels.Models != null && Model < DemoModels.Models.Count)
			{
				var model = DemoModels.Models[Model];
				if (model.Grouped.Surfaces != null)
				{
					name = model.Name;
					mesh = model.Greedy;
					width = model.Model.Width;
					height = model.Model.Height;
					depth = model.Model.Depth;
				}
			}

			if (UseDesiredWidth)
			{
				FaceSize = (int)DesiredWidth / width;
			}
		}

		@if (mesh != null)
		{
			<div class="mesh" style="width: @(FaceSize * width)px; height: @(FaceSize * height)px; transform: rotateX(@(Pitch)deg) rotateY(@(Direction)deg)">
				<div class="element" style="transform: scale3d(@Scale, -@Scale, @Scale) translate3d(0, @(((FaceSize * height * -1.0f)))px, @(FaceSize * (depth) * -0.5f)px)">
					@foreach (var surfaceGroup in mesh.Value.Surfaces.GroupBy(surf => new SurfaceDescription()
					{
						Normal = surf.Description.Normal,
						Depth = surf.Description.Depth
					}))
					{
						<img src="@EncodeSvg(RenderSVG(surfaceGroup))" class="surface" style="transform: @ToTransform(surfaceGroup.Key)" />
					}
				</div>
			</div>

			<p>@name</p>
		}
	</div>

</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Model</div>
	<div style="width: 64px;">@Model</div>
	<input type="range" style="flex-grow: 1" min="0" max="@(DemoModels.Models?.Count - 1 ?? 0)" @bind="@Model" @bind:event="oninput" />
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Direction</div>
	<div style="width: 64px;">@Direction</div>
	<input type="range" style="flex-grow: 1" min="0" max="360" @bind="@Direction" @bind:event="oninput" />
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Pitch</div>
	<div style="width: 64px;">@Pitch</div>
	<input type="range" style="flex-grow: 1" min="-90" max="90" @bind="@Pitch" @bind:event="oninput" />
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Scale</div>
	<div style="width: 64px;">@Scale</div>
	<input type="range" style="flex-grow: 1" min="0.01" max="1" step="0.01" @bind="@Scale" @bind:event="oninput" />
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Width</div>
	<input type="checkbox" style="width: 64px" @bind="@UseDesiredWidth" @bind:event="oninput" />
	<div style="width: 64px;">@DesiredWidth</div>
	<input type="range" style="flex-grow: 1" min="50" max="1000" step="10" @bind="@DesiredWidth" @bind:event="oninput" />
</div>

@code {
	private int FaceSize = 50;
	private float Scale = 1.0f;

	private int Model = 0;

	private float Pitch = -45.0f;
	private float Direction = 30.0f;

	private bool UseDesiredWidth = true;
	private float DesiredWidth = 140;

	protected override async Task OnInitializedAsync()
	{
		await DemoModels.Init(Http);
	}
}

@functions {
	public string ToTransform(SurfaceDescription surface)
	{
		var normal = surface.Normal;
		int depth = surface.Depth;

		if (normal == VoxelNormal.Up)
		{
			return $"rotateX(90deg) translate3d(0, 0, {depth * -FaceSize}px)";
		}
		else if (normal == VoxelNormal.Down)
		{
			return $"rotateX(90deg) translate3d(0, 0, {depth * FaceSize}px)";
		}
		else if (normal == VoxelNormal.Left)
		{
			return $"rotateY(-90deg) translate3d(0px, 0, {depth * FaceSize}px)";
		}
		else if (normal == VoxelNormal.Right)
		{
			return $"rotateY(-90deg) translate3d(0px, 0, {depth * -FaceSize}px)";
		}
		else if (normal == VoxelNormal.Back)
		{
			return $"translate3d(0, 0, {depth * -FaceSize}px)";
		}
		else if (normal == VoxelNormal.Forward)
		{
			return $"translate3d(0, 0, {depth * FaceSize}px)";
		}
		return "";
	}

	public string EncodeSvg(string svg)
	{
		var urlEncoded = UrlEncoder.Default.Encode(svg);

		return "data:image/svg+xml," + urlEncoded;
	}

	public string RenderSVG(IGrouping<SurfaceDescription, GreedySurface> greedySurfaces)
	{
		sbyte maxX = 0;
		sbyte maxY = 0;

		foreach (var surface in greedySurfaces)
		{
			foreach (var face in surface.Faces)
			{
				maxX = Math.Max(maxX, face.TopRight.x);
				maxY = Math.Max(maxY, face.TopRight.y);
			}
		}

		var sb = new StringBuilder();

		sb.Append("<svg xmlns=\"http://www.w3.org/2000/svg\" role=\"img\" viewBox=\"0 0 ");

		sb.Append(maxX * FaceSize);

		sb.Append(" ");

		sb.Append(maxY * FaceSize);

		sb.Append("\" width=\"");

		sb.Append(maxX * FaceSize);

		sb.Append("\" height=\"");

		sb.Append(maxY * FaceSize);

		sb.Append("\">");

		foreach (var surface in greedySurfaces)
		{
			foreach (var face in surface.Faces)
			{
				sb.Append("<rect x=\"");
				sb.Append((face.Position.x * FaceSize) - 1);

				sb.Append("\" y=\"");

				sb.Append((face.Position.y * FaceSize) - 1);

				sb.Append("\" width=\"");

				sb.Append((face.Scale.x * FaceSize) + 1);

				sb.Append("\" height=\"");

				sb.Append((face.Scale.y * FaceSize) + 1);

				sb.Append("\" style=\"fill: ");

				sb.Append(surface.Description.Colour.ToHexString());

				sb.Append("\" />");

			}
		}
		sb.Append("</svg>");

		return sb.ToString();
	}
}
