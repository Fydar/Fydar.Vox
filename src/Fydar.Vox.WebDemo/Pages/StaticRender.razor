@using Fydar.Vox.Meshing;
@using System;
@using System.Numerics;
@using Fydar.Vox.VoxFiles;

@page "/staticrender"
@inject HttpClient Http

<h1>Static Render</h1>

<style>
	.scene {
		display: inline-block;
		padding: 50px;
		perspective: 2048px;
		border: 1px solid #eee;
		overflow: hidden;
	}

	.mesh {
		position: relative;
		width: 250px;
		height: 500px;
		margin: auto;
		transform-style: preserve-3d;
		transition: transform 0.6s;
	}

	.surface {
		transform-origin: 0% 0%;
	}

	.surface div {
		position: absolute;
		width: @(faceSize)px;
		height: @(faceSize)px;
		border: 1px solid #0006;
	}
</style>

<div class="scene">
	@{
		GreedyMesh? mesh = null;
		int width = 1;
		int height = 1;
		int depth = 1;

		if (DemoModels.Models != null && Model < DemoModels.Models.Count)
		{
			var model = DemoModels.Models[Model];
			if (model.Grouped.Surfaces != null)
			{
				mesh = model.Greedy;
				width = model.Model.Width;
				height = model.Model.Height;
				depth = model.Model.Depth;
			}
		}
	}

	@if (mesh != null)
	{
		<div class="mesh" style="width: 512px; height: 512px; transform: scale(@Scale) scaleY(-1) rotateX(@(Pitch)deg) rotateY(@(Direction)deg) translate3d(@(faceSize * (width - 1) * -0.5f)px, 0, @(faceSize * (depth - 1) * -0.5f)px) ">

			@foreach (var surfaceGroup in mesh.Value.Surfaces.GroupBy(surf => new SurfaceDescription()
			{
				Normal = surf.Description.Normal,
				Depth = surf.Description.Depth
			}))
			{
				<div class="surface" style="transform: @ToTransform(surfaceGroup.Key)">
					@foreach (var surface in surfaceGroup)
					{
						@foreach (var face in surface.Faces)
						{
							<div class="face" style="width: @(face.Scale.x * faceSize)px;
										height: @(face.Scale.y * faceSize)px;
										transform: translate(@(face.Position.x * faceSize)px, @(face.Position.y * faceSize)px);
										background-color: @surface.Description.Colour.ToHexString();">

							</div>
						}
					}
				</div>
			}
		</div>
	}
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Model</div>
	<div style="width: 64px;">@Model</div>
	<input type="range" style="flex-grow: 1" min="0" max="@(DemoModels.Models?.Count - 1 ?? 0)" @bind="@Model" @bind:event="oninput" />
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Direction</div>
	<div style="width: 64px;">@Direction</div>
	<input type="range" style="flex-grow: 1" min="0" max="360" @bind="@Direction" @bind:event="oninput" />
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Pitch</div>
	<div style="width: 64px;">@Pitch</div>
	<input type="range" style="flex-grow: 1" min="-90" max="90" @bind="@Pitch" @bind:event="oninput" />
</div>

<div class="input-group">
	<div style="width: 96px; font-weight: bold;">Scale</div>
	<div style="width: 64px;">@Scale</div>
	<input type="range" style="flex-grow: 1" min="0.01" max="1" step="0.01" @bind="@Scale" @bind:event="oninput" />
</div>

@code {
	static int faceSize = 50;
	private float Scale = 0.5f;

	private int Model = 0;

	private float Pitch = 45.0f;
	private float Direction = 30.0f;

	protected override async Task OnInitializedAsync()
	{
		await DemoModels.Init(Http);
	}
}

@functions {
	public static string ToTransform(SurfaceDescription surface)
	{
		var normal = surface.Normal;
		int depth = surface.Depth;

		if (normal == VoxelNormal.Up)
		{
			return $"rotateX(90deg) translate3d(0, 0, {depth * -faceSize}px)";
		}
		else if (normal == VoxelNormal.Down)
		{
			return $"rotateX(90deg) translate3d(0, 0, {depth * faceSize}px)";
		}
		else if (normal == VoxelNormal.Left)
		{
			return $"rotateY(-90deg) translate3d(0px, 0, {depth * faceSize}px)";
		}
		else if (normal == VoxelNormal.Right)
		{
			return $"rotateY(-90deg) translate3d(0px, 0, {depth * -faceSize}px)";
		}
		else if (normal == VoxelNormal.Back)
		{
			return $"translate3d(0, 0, {depth * -faceSize}px)";
		}
		else if (normal == VoxelNormal.Forward)
		{
			return $"translate3d(0, 0, {depth * faceSize}px)";
		}
		return "";
	}
}
